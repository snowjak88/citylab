iteratingSystem 'tradeExecutionSystem', Family.all( IsPendingTrade ).get(), { entity, deltaTime ->
	
	//
	// As we receive IsPendingTrade entities (generated by the Markets module),
	// we should turn those into:
	//
	//  1) instant inventory credits/debits (if the trade is instant)
	//  2) a commodity-delivery (if the trade is not)
	//
	
	final pendingTrade = pendingTradeMapper.get(entity)
	
	if(pendingTrade.instant) {
		
		//
		// Credit and debit inventories ...
		if(pendingTrade.from && pendingTrade.to && pendingTrade.commodity && pendingTrade.quantity > 0) {
			
			final fromInventory = inventoryMapper.get( pendingTrade.from )
			
			if( ( fromInventory[commodityID] ?: 0 ) >= pendingTrade.quantity ) {
				
				def toInventory = inventoryMapper.get( pendingTrade.to )
				if(!toInventory)
					toInventory = pendingTrade.to.addAndReturn( state.engine.createComponent( HasCommodityInventory ) )
				
				fromInventory[pendingTrade.commodityID] = ( fromInventory[pendingTrade.commodityID] ?: 0 ) - pendingTrade.quantity
				toInventory[pendingTrade.commodityID] = ( toInventory[pendingTrade.commodityID] ?: 0 ) + pendingTrade.quantity
				
			}
			
		}
		
		//
		// ... and delete this entity, as we don't need it anymore
		state.engine.removeEntity entity
		
	} else {
		
		//
		// Create a new commodity-delivery ...
		
		//
		// ... and delete this PendingTrade component
		entity.remove IsPendingTrade
	}
	
}